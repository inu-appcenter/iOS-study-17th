# 오류 처리

### 1. **오류 표현: Error 프로토콜과 열거형**

Swift에서 오류는 `Error` 프로토콜을 준수하는 타입으로 표현됩니다. 주로 `enum`을 사용하여 오류의 종류를 정의합니다. 열거형은 각 오류 케이스를 명확히 정의하고, 연관 값(associated values)을 통해 추가 정보를 포함할 수 있습니다.

### 코드 예시

```swift
enum VendingMachineError: Error {
    case invalidInput
    case insufficientFunds(moneyNeeded: Int)
    case outOfStock
}

```

- **설명**
    - `invalidInput`: 잘못된 입력(예: 음수 금액, 잘못된 수량 등)을 나타냅니다.
    - `insufficientFunds(moneyNeeded: Int)`: 필요한 금액이 부족할 때 사용되며, 부족한 금액을 연관 값으로 전달합니다.
    - `outOfStock`: 재고가 부족한 경우를 나타냅니다.
    - `Error` 프로토콜을 채택하여 이 열거형이 Swift의 오류 처리 시스템에 통합됩니다.

### 추가 설명

- 열거형은 오류를 체계적으로 분류하는 데 적합하며, 연관 값을 통해 오류의 구체적인 원인을 전달할 수 있습니다.
- `Error` 프로토콜은 빈 프로토콜로, 별도의 메서드나 속성을 요구하지 않으므로 어떤 타입이든 이를 채택해 오류로 사용할 수 있습니다.

---

### 2. **오류를 던지는 함수: `throws`**

Swift에서 오류를 발생시킬 가능성이 있는 함수나 메서드는 `throws` 키워드를 사용하여 선언합니다. 이를 통해 호출자가 오류 처리 코드를 작성해야 함을 명시합니다.

### 코드 예시

```swift
class VendingMachine {
    let itemPrice: Int = 100
    var itemCount: Int = 5
    var deposited: Int = 0

    func receiveMoney(_ money: Int) throws {
        guard money > 0 else {
            throw VendingMachineError.invalidInput
        }
        self.deposited += money
        print("\\(money)원 받음")
    }

    func vend(numberOfItems numberOfItemsToVend: Int) throws -> String {
        guard numberOfItemsToVend > 0 else {
            throw VendingMachineError.invalidInput
        }
        guard numberOfItemsToVend * itemPrice <= deposited else {
            let moneyNeeded = numberOfItemsToVend * itemPrice - deposited
            throw VendingMachineError.insufficientFunds(moneyNeeded: moneyNeeded)
        }
        guard itemCount >= numberOfItemsToVend else {
            throw VendingMachineError.outOfStock
        }
        let totalPrice = numberOfItemsToVend * itemPrice
        self.deposited -= totalPrice
        self.itemCount -= numberOfItemsToVend
        return "\\(numberOfItemsToVend)개 제공함"
    }
}

```

- **설명**:
    - `receiveMoney(_:)`: 입력된 금액이 0 이하일 경우 `invalidInput` 오류를 던집니다. 정상 처리 시 `deposited`에 금액을 추가합니다.
    - `vend(numberOfItems:)`: 구매하려는 수량이 잘못되었거나, 금액이 부족하거나, 재고가 없으면 각각 해당 오류를 던집니다. 정상 처리 시 재고와 잔액을 갱신하고 결과를 반환합니다.
    - `guard` 문을 사용하여 조건이 충족되지 않을 경우 `throw`로 오류를 던집니다.

### 추가 설명

- `throws`는 함수가 오류를 던질 수 있음을 나타내며, 호출자는 이를 처리해야 합니다.
- `guard` 문은 오류 조건을 빠르게 확인하고, 조건이 맞지 않을 경우 `throw`로 빠져나가는 패턴을 제공합니다.
- 연관 값(`moneyNeeded`)을 통해 호출자에게 부족한 금액 같은 추가 정보를 제공할 수 있습니다.

---

### 3. **오류 처리: `do-catch`, `try?`, `try!`**

Swift에서 오류를 처리하는 방법은 `do-catch`, `try?`, `try!` 세 가지 주요 방식이 있습니다.

### 3.1 **do-catch**

`do-catch`는 가장 정석적인 오류 처리 방식으로, 모든 오류 케이스를 명시적으로 처리할 수 있습니다.

### 코드 예시 1: 개별 오류 케이스 처리

```swift
do {
    try machine.receiveMoney(0)
} catch VendingMachineError.invalidInput {
    print("입력이 잘못되었습니다")
} catch VendingMachineError.insufficientFunds(let moneyNeeded) {
    print("\\(moneyNeeded)원이 부족합니다")
} catch VendingMachineError.outOfStock {
    print("수량이 부족합니다")
}
// 출력: "입력이 잘못되었습니다"

```

- **설명**: 각 오류 케이스에 대해 별도의 `catch` 블록을 작성하여 개별적으로 처리합니다.

### 코드 예시 2: `switch`를 사용한 처리

```swift
do {
    try machine.receiveMoney(300)
} catch {
    switch error {
    case VendingMachineError.invalidInput:
        print("입력이 잘못되었습니다")
    case VendingMachineError.insufficientFunds(let moneyNeeded):
        print("\\(moneyNeeded)원이 부족합니다")
    case VendingMachineError.outOfStock:
        print("수량이 부족합니다")
    default:
        print("알수없는 오류 \\(error)")
    }
}
// 출력: "300원 받음"

```

- **설명**: `catch` 블록 내에서 `switch`를 사용하여 오류를 분류합니다. `default` 케이스는 예상치 못한 오류를 처리합니다.

### 코드 예시 3: 간소화된 처리

```swift
do {
    result = try machine.vend(numberOfItems: 4)
} catch {
    print(error)
}
// 출력: "insufficientFunds(100)"

```

- **설명**: 오류 케이스를 세분화하지 않고 단순히 오류를 출력합니다. 간단한 오류 처리에 유용합니다.

### 추가 설명

- `do` 블록 내에서 `try`를 사용하여 오류를 던질 수 있는 함수를 호출합니다.
- `catch` 블록은 특정 오류 타입을 패턴 매칭으로 처리하거나, 모든 오류를 `error`로 받아 처리할 수 있습니다.
- `catch` 없이 `do`만 사용할 수도 있지만, 이 경우 오류가 처리되지 않아 컴파일 오류가 발생합니다.

### 3.2 **try?**

`try?`는 오류를 처리하지 않고, 성공 시 반환값을 `Optional`로, 실패 시 `nil`을 반환합니다.

### 코드 예시

```swift
result = try? machine.vend(numberOfItems: 2)
print(result) // Optional("2개 제공함")
result = try? machine.vend(numberOfItems: 2)
print(result) // nil

```

- **설명**:
    - 성공 시 반환값은 `Optional`로 래핑됩니다.
    - 실패 시 `nil`을 반환하며, 어떤 오류가 발생했는지 알 수 없습니다.
- **사용 시기**: 오류의 구체적인 원인을 알 필요가 없고, 성공/실패 여부만 확인하면 되는 경우에 유용합니다.

### 3.3 **try!**

`try!`는 오류가 발생하지 않을 것이라는 확신이 있을 때 사용하며, 오류 발생 시 런타임 오류(crash)가 발생합니다.

### 코드 예시

```swift
result = try! machine.vend(numberOfItems: 1)
print(result) // "1개 제공함"
// result = try! machine.vend(numberOfItems: 1)
// 런타임 오류 발생!

```

- **설명**:
    - 오류가 발생하지 않을 것이라는 강한 확신이 있을 때 사용합니다.
    - 오류가 발생하면 앱이 크래시되므로 주의해서 사용해야 합니다.
- **사용 시기**: 디버깅 또는 테스트 환경, 혹은 절대 오류가 발생하지 않는다고 보장되는 상황에서만 사용합니다.

### 4. 정리

Swift의 오류 처리 시스템은 `Error` 프로토콜, `throws`, `try`, `do-catch`, `try?`, `try!`를 통해 강력하고 유연한 오류 관리를 제공합니다. 자판기 예제를 통해 오류 정의, 발생, 처리 방법을 살펴보았으며, 이를 통해 다음과 같은 점을 알 수 있습니다:

- 오류는 열거형과 `Error` 프로토콜로 체계적으로 정의합니다.
- `throws`로 오류 발생 가능성을 명시하고, `do-catch`로 세부적으로 처리하거나 `try?`, `try!`로 간단히 처리할 수 있습니다.
- 상황에 맞는 오류 처리 방식을 선택하여 코드의 안정성과 가독성을 높이는 것이 중요